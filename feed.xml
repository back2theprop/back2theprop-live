<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://back2theprop.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://back2theprop.com/" rel="alternate" type="text/html" hreflang="en" /><updated>2021-05-24T08:33:18+03:00</updated><id>https://back2theprop.com/feed.xml</id><subtitle>Website dedicated towards machine learning tutorials and explanations, and everything tangentially relevant to the field.</subtitle><author><name>Wiem Ben Rim &amp; Ahmad Moussa</name></author><entry><title type="html">A guide to pre-processing Spectrograms</title><link href="https://back2theprop.com/blog/A-guide-to-pre-processing-spectrograms" rel="alternate" type="text/html" title="A guide to pre-processing Spectrograms" /><published>2021-05-16T00:00:00+03:00</published><updated>2021-05-16T00:00:00+03:00</updated><id>https://back2theprop.com/blog/A-guide-to-pre-processing-spectrograms</id><content type="html" xml:base="https://back2theprop.com/blog/A-guide-to-pre-processing-spectrograms">&lt;p&gt;There are a lot of things that I wish I would have known when I dove head first into my Masters, and as silly as it sounds, one of them being how to pre-process your data correctly. Machine Learning models are only as good as the data that you feed them, and if you feed it garbage you’re very likely to end up with garbage outputs. Which is something that me and probably many others had to learn the hard way. Your models will not somehow magically look past all the problems in your data and miraculously learn exactly what you want them to learn (even though I hope that this aspect will become easier to handle in the future).&lt;/p&gt;

&lt;p&gt;A large portion of your data-sciecing time should be spent on data-collection, curation and clean-up. Many open source tools exist for these purposes and are relatively easy to utilize, but sometimes you’ll still need to curl up your sleeves and concoct a python script that does what you want. My biggest gripe with data pre-processing is that it’s usually always neglected and merely brushed over in research paper, rather than explaining it in a ‘tell me exactly what you did’ manner, such that it is in the realm of possibility to reproduce the reported results.&lt;/p&gt;

&lt;p&gt;Getting back to the main point of this post, which is pre-processing Spectrograms and treating them as images. If you’ve followed the trends of deep learning and sound synthesis in recent years, you’ve probably come across some models that utilize GANs for this purpose. One of them being SpecGAN, short for Spectrogram Generative Adversarial Networks. Which simply is a GAN that is capable of generating spectrogram representations of sound, the spectrogram being treated as a digital image.&lt;/p&gt;

&lt;p&gt;The first time I came across the paper, this sounded like a superb idea, why deal with data in the time domain if we already have strong models for image synthesis? However, this domain conversion usually comes with two caveats:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;How exactly do we treat a spectrogram as an Image?&lt;/li&gt;
  &lt;li&gt;How do we get the actual audio from the Spectrogram?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’re not familiar with what Spectrograms are, then I got you covered with this previous blog post of mine. For now we need not concern ourselves in depth with spectrogram inversion methods (if you would like to learn more details about them check this post), we’ll just assume that we have a ‘good-enough’ method for doing so.&lt;/p&gt;

&lt;h3&gt;The Nitty Gritty of Spectrogram Pre-rocessing&lt;/h3&gt;
&lt;p&gt;Spectrogram pre-processing can be split into several stages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Processing the audio data itself before passing it through the STFT&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;The STFT parameters&lt;/li&gt;
  &lt;li&gt;Processing the spectrogram&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;About Audio Data Normalization&lt;/h3&gt;
&lt;p&gt;Normalizing audio can be a step that is often disregarded as a primer in your pipeline. Making sure that your data samples are as clean as representative as possible is crucial for steps further down the line.&lt;/p&gt;

&lt;p&gt;We’ve previously talked about sample-rate and bit-depth, and the first thing you want to ensure that all samples in your dataset have the same sample-rate. Bit depth is less important, you probably can get away with having different bit-depths, but ideally we’ll also want to make sure that all samples have a similar bit-depth.&lt;/p&gt;

&lt;h3&gt;About STFT parameter Selection&lt;/h3&gt;
&lt;p&gt;The main STFT parameters are usually the window length, the hop size and the signal length. For our purposes we will be dealing with short audio sampples, and it makes the most sense to select a specific sample length.&lt;/p&gt;</content><author><name>Ahmad</name></author><category term="audio" /><category term="data" /><category term="FFT" /><category term="spectrograms" /><category term="audio," /><category term="fourier," /><category term="spectrograms" /><summary type="html">There are a lot of things that I wish I would have known when I dove head first into my Masters, and as silly as it sounds, one of them being how to pre-process your data correctly. Machine Learning models are only as good as the data that you feed them, and if you feed it garbage you’re very likely to end up with garbage outputs. Which is something that me and probably many others had to learn the hard way. Your models will not somehow magically look past all the problems in your data and miraculously learn exactly what you want them to learn (even though I hope that this aspect will become easier to handle in the future).</summary></entry><entry><title type="html">Audio Data, Fourier Transform and Spectrograms</title><link href="https://back2theprop.com/blog/Audio-Data-Fourier-Transform-and-Spectrograms" rel="alternate" type="text/html" title="Audio Data, Fourier Transform and Spectrograms" /><published>2021-05-15T00:00:00+03:00</published><updated>2021-05-15T00:00:00+03:00</updated><id>https://back2theprop.com/blog/Audio-Data-Fourier-Transform-and-Spectrograms</id><content type="html" xml:base="https://back2theprop.com/blog/Audio-Data-Fourier-Transform-and-Spectrograms">&lt;p&gt;Audio data can be represented in many different ways, some more useful than others for different machine learning and deep learning applications. The most famous being the Spectrogram, which illustrates the frequency components of a specific signal. Spectrogram representations, in combination with modern deep learning models tailored towards image classification and image processing, allow us to unlock a completely new perspective on solving audio related tasks. This article’s goal is to explain how we go from recorded audio to spectrogram representation in detail, with a brief explanation of the fourier transform, and assumes no prior knowledge on the subject.&lt;/p&gt;

&lt;h2&gt;Audio Data&lt;/h2&gt;
&lt;p&gt;The way audio is stored on modern systems is an abstraction of what audio is in the real world. On a hard drive audio data is stored as a floating point array of numbers, which essentially captures the amplitude of a signal at different points in time. To get an intuitive idea of spectrograms, is probably best to backtrack a little, and have a look at what sound actually is, and how it’s different properties.&lt;/p&gt;

&lt;p&gt;In the physical world, a perceived sound wave can be regarded as a compression of particles, propagating through the space near and around your ear. More concretely, if you pop a balloon, you’ll hear a clapping sound which is due to the air, that was compressed inside the balloon, rushing out into all directions. When this pressure wave finds our ear, a thin stretch of skin that resides at the end of the ear canal begins to vibrate. Once in vibration, the ear drum fires a signal to our brain, which is then decoded into semantic information which we can understand and classify. Now the apparatus that sits between our ear and our brain is quite intricate and I highly recommend you to learn more about it. For the purposes of this article, this simple explanation is sufficient however.&lt;/p&gt;

&lt;p&gt;Now we can already make two very fascinating observations, firstly, that sounds come in many different flavors and secondly, that our human brain is capable of discerning and classifying these different sounds. Think about it, someone drops something in the other room, and you can probably tell what material that object was made of, or even more impressively we can understand and decode words and sentences uttered by someone else, and all of that in a matter of milliseconds and incredibly effortlessly. From an evolutionary point of view, the ability of hearing (and communication) things and understanding what they were probably contributed a great deal to our development as a species.&lt;/p&gt;

&lt;p&gt;But back to machines, we’ve only very recently been able to make advances in machine perception and audio classification with convolutional deep learning models, and many of these models actually don’t interact with audio signals directly, but rather on spectrograms, as they’re much easier to deal with. More on that later, first let’s have a look at how we go from raw audio to a spectrogram representation.&lt;/p&gt;

&lt;h3 id=&quot;a-little-bit-about-recorded-audio&quot;&gt;A little bit about recorded audio&lt;/h3&gt;
&lt;p&gt;In a similar way to how the human ear works, we designed microphones to behave in a very similar manner. Microphones usually consist of a diaphragm that begins vibrating when it is met with sound (like the ear drum), this diaphragm then converts sound waves into an electrical signal via transduction, transduction being the convertion of one type of energy into another type of energy. Here we’re converting pressure waves into an electrical current. We can then record the amplitude of this electric signal at every given moment over a specific period of time, and simply store this sequence as an array of numbers on disc.&lt;/p&gt;

&lt;p&gt;Obviously, in the physical world, sound is a continuous signal, which we are now abstracting as a discrete sequence, which can be parametrized (defined, described by) with mainly 2 parameters: sampling rate and bit depth. The number of times at which we take snapshots of the amplitude with our microphone is regarded as the sampling rate. For example, if we were to take 16000 samples per second the sampling rate of the recorded signal would be 16KHz (Kilo Hertz). The sampling rate of a signal is essentially it’s temporal resolution, meaning that if we were to take more snapshots in the same amount of time, we would end up with a better quality recording. The second parameter is the bit depth of the signal, which describes the number of bits used to encode each individual sample. Which is essentially the resolution of each individual sample taken, and like before higher bit-depth means more quality (there is an upper limit though). If you’d like to learn a little bit more about digital audio I recommend this &lt;a href=&quot;https://www.izotope.com/en/learn/digital-audio-basics-sample-rate-and-bit-depth.html&quot;&gt;read&lt;/a&gt; by izotope.&lt;/p&gt;

&lt;p&gt;Great, we now have established a discrete time-signal that can serve as an abstraction of sound waves in the real world.&lt;/p&gt;

&lt;h3 id=&quot;what-is-frequency-phase&quot;&gt;What is Frequency? Phase?&lt;/h3&gt;
&lt;p&gt;However, there’s a little more to sound than just sampling rate and bit depth. You’ve probably heard about frequency and phase before, and have a vague idea of what they are but don’t feel like you have a good grasp on these concepts. This was my situation before digging into the topic in more depth, and it took me a while to be able to explain these concepts to myself. This section serves as an explanation, to give you an understanding of both frequency and phase.&lt;/p&gt;

&lt;p&gt;Usually, no two sounds occur the exact same way twice (except if played by a machine). If you clap your hands twice in a row, it is quiet impossible to produce the exact same sound twice. We’re talking microscopic levels of ‘exact’ here. The compression of particles that occurs when you clap your hands happens at different rates, meaning that some particles will be displaced harder and faster than others. This makes it such that different sound waves reach your ear at different speeds. The speed at which sound waves travel to your ear (the speed at which air particles wiggle back and forth) is what we call Frequency.&lt;/p&gt;

&lt;p&gt;This might be a bit obscure, but basically, when you clap your hands, you’re creating a number of different pressure waves that reach your ear. This combination of different pressure waves is what characterizes specific sounds. For example, you’ll probably agree, that when you clap your hands you probably won’t hear the sound of an ambulance siren, and no matter how hard you try, you’ll probably never be able to produce the sound of an ambulance siren by clapping your hands. However, with the deformable vocal apparatus connected to the bottom of your head, you can immitate, to a certain degree, many sounds such as a clapping sound or the sound of a siren. If a sound were to consist of only a single frenquecy we would call it a pure tone, which does not generally occur in nature. To conclude, you can think about a frequency as an oscillation at a very specific speeds.&lt;/p&gt;

&lt;p&gt;Sounds in the real world consist of many different frequencies occuring at the same time, overlapping and interleaving with each other to construct intricate and extremely distinguishable sounds. This brings up another important aspect of sound, namely ‘phase’. Phase information, describes how different frequencies, that make up a sound, are aligned with respect to each other. A good visual example would be race cars on a circular race track, two cars might be racing side by side, but one of them might already be a lap ahead, which you wouldn’t be able to determine by simply looking at them. Obviously, it’s not as simple as that, but this kind of understanding should be sufficient for now.&lt;/p&gt;

&lt;h3 id=&quot;nyquist-theorem&quot;&gt;Nyquist Theorem&lt;/h3&gt;
&lt;p&gt;Before we talk more about frequency and how to represent it, we’ll make a small detour and look at samlping rate again. Arguably, the most popular sampling rate for audio data is 44.1KHz. This is due to two reasons, firstly because it’s the sampling rate at which audio is encoded on the good old compact disc (CD), and secondly because it satisfies the Nyquist Theorem. Well, it’s really only one reason, because the CDs sampling rate was chosen to satisfy the Nyquist Theorem. The name might sound intimidating, but it’s a quite simple rule actually. Human hearing has an upper limit of around 20KHz, meaning that we can’t hear frequencies higher than that. How does this relate to the Nyquist Theorem? Well, the Nyquist theorem states that for a discrete sequence to capture all the information from a continuous signal, the sampling rate has to be twice as much as the highest frequency component in that signal. Why exactly this holds is a bit more difficult to explain, and will be covered in a future post, but for now I think you can already see why this is important. Since our upper limit for hearing is 20KHz, a sampling rate of 44.1KHz is more than enough to capture all the frequencies that we could possibly experience.&lt;/p&gt;

&lt;h3 id=&quot;the-spectrogram&quot;&gt;The Spectrogram&lt;/h3&gt;
&lt;p&gt;We have now established two different reresentations for audio, one that approximately describes the continuous signal in the physical world, and another that describes it by it’s individual frequencies and how they are aligned with each other. The first can simply be represented by a discrete array of numbers, whereas frequency and phase information can be represented by a spectrogram. Before we discuss how we actually obtain the spectrogram, it might be beneficial to have a look at a spectrogram and it’s parts. A spectrogram usually has 3 axis: frequency on the y-axis, time on the x-axis and amplitude represented by color. Let’s have a look at an example:&lt;/p&gt;

&lt;p&gt;Let’s inspect each of these three axis in more detail.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The x-axis that represents time, and shows how the different frequencies behave over time (more to this later).&lt;/li&gt;
  &lt;li&gt;The y-axis represents the different frequencies present in the signal, rom low to high frequencies. Since the physical world is continuous, this axis is also a discretization, where a segment on the axis is oftentimes called a frequency bin. Where a bin consists of a number of frequencies grouped together and their amplitudes added together.&lt;/li&gt;
  &lt;li&gt;Color on the other hand, can be considered the third axis, and is represented by brightness. Similarly to a heatmap, the brighter a specific spot is, the higher the intensity of a specific frequency at that point, intensity being the amplitude in this case.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You might have noticed already, but phase information is not included in this spectrogram, and there is a good reason for that.&lt;/p&gt;

&lt;h3 id=&quot;the-fourier-transform&quot;&gt;The Fourier Transform&lt;/h3&gt;
&lt;p&gt;We’re getting closer to the meat of the story, the problem at hand is, how do we actually obtain this spectrogram representation? To be more precise, how do we transition from a discretized time-signal towards a frequency representation? Retrieving the different frequencies that occur in a specific recording, might be problematic. At the time of recording, we observed the amplitude of the signal reaching the diaphragm of the microphone, where the recorded amplitude already consisted of a mixture of different frequencies. At this point it would seem impossible to obtain the different frequencies! It would be similar to trying to retrieve the initial ingredients and fruits that went into the making of a smoothie with a blender.&lt;/p&gt;

&lt;p&gt;Luckily we can accomplish this with most modern programming frameworks in a couple lines of code! this is thanks to the Fourier transform, which is named after it’s creator. It is actually very likely that you’ve used technology that implements a fourier transform in some manner (spoilers: your phone). Essentially, what the fourier transform allows us to do, is to convert a time domain signal into a frequency reresentation. The formula for the fourier transform can look a little scary, but don’t fret for now, it’ll be clear in a second. The formula:&lt;/p&gt;

&lt;p&gt;I strongly believe that it is much easier to understand the Fourier transform by understanding how it accomplishes this disentanglement, rather than working through the math immediately. The fundamental concept that the fourier transform builds on, is that any signal can be represented by a combination of a number of simpler signals. In this case this simple signal will be a sine wave. This is great! The fourier transform thus tries to find these simpler sine waves that make up our original signal. Of course, in the physical world, not all oscillations are sine waves, but they are more than sufficient to approximate the frequency content in a given signal.&lt;/p&gt;

&lt;p&gt;The single most illustrative resource on the fourier transform that I could find is &lt;a href=&quot;https://www.youtube.com/watch?v=spUNpyF58BY&amp;amp;ab_channel=3Blue1Brown&quot;&gt;this YouTube video&lt;/a&gt; by Grant Sanderson, who runs his channel under the alias 3blue1brown. I have watched this video more times than I would like to admit, and still feel like I am learning a little something new every time I do. Explaining in 3blue1brown terms, the formula you see above wraps our recorded signal around a circle, and imagine that this signal we just ‘wound’ around the circle has a certain weight to it (similar to a metal wire), the red dot representing it’s center of mass. We now wind this wire evermore tightly around the circle and record the position of it’s center of mass relative to the center of the circle. Observing a large deviation signifies the presence of a specific frequency. This process is illustrated in the gif below, which is actually an excerpt of Grant Sanderson’s video.&lt;/p&gt;

&lt;div style=&quot;position:relative; padding-bottom:calc(56.25% + 44px)&quot;&gt;&lt;iframe src=&quot;https://gfycat.com/ifr/CautiousImaginativeCaimanlizard&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute;top:0;left:0;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt; &lt;a href=&quot;https://gfycat.com/cautiousimaginativecaimanlizard&quot;&gt;via Gfycat&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the gif above, the original signal is a simple sine wave, oscillating at 3 beats per second. Meaning that it has a frequency of 3 beats per second. By wrapping it around the unit circle and incrementally tightening it, we will observe a deviation from it’s center of mass at this very specific frequency. Attempting to re-explain the Fourier Transform, when there already are so many great resources that do an amazing job at it would be futile, here are three more resources, with varying degrees of difficulty, that should be more than sufficient to help you understand the history and mathematics behind the fourier transform:
1.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;‘Highlights in the history of the Fourier Transform’ by Alejandro Dominquez is a great read and can be found &lt;a href=&quot;https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7389485&quot;&gt;here&lt;/a&gt;. The introduction provides a nice recount of Fourier’s life, before moving on to a quite in depth analysis of the transform.&lt;/li&gt;
  &lt;li&gt;More historical context behind the fourier transform can be found in the article titled &lt;a href=&quot;https://www.yalescientific.org/2010/12/fourier-transform-natures-way-of-analyzing-data/#:~:text=Fourier%2C%20a%20French%20military%20scientist,transfer%20in%20the%20late%201790s.&amp;amp;text=During%20this%20time%2C%20his%20obsession,transform%20to%20solve%20this%20equation.&quot;&gt;Fourier Transform: Nature’s Way of Analyzing Data&lt;/a&gt; by Rohit Thummalapalli.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;DFT, FFT, STFT&lt;/h2&gt;
&lt;p&gt;For someone new to all of this, the lingo might be quite confusing. The type of Fourier Transform that we use today is the DFT, short for Discrete Fourier Transform. The DFT is used on Discrete Time Signals, such as arrays of numbers representing audio signals (but can be used for all sorts of discrete time signals such as seismic information for example). The word ‘discrete’ literally meanining: individually separate and distinct. FFT stands for Fast Fourier Transform, which is simply a faster and more efficient implementation of the DFT, which is commonly use nowadays.&lt;/p&gt;

&lt;p&gt;Now the last things we need to clear up is, why isn’t there any phase information in the Spectrogram? The Fourier Transform actually returns a matrix of complex numbers, where the real components represent the frequency information in the signal, and the imaginary components the phase information. This is why we also call the of spectrogram we showed earlier a ‘Magnitude’ Spectrogram, because it simply shows the magnitudes of the frequencies present in the signal. The phase information is not included.&lt;/p&gt;

&lt;p&gt;This begs the question, why do we have a time axis in the spectrogram then? This is because we don’t actually compute the Fourier Transform of the entire signal, we compute many DFTs of smaller chunks of the signal, and then collate them in the spectrogram image we showed. Computing the FT for the entire signal would simpply give us a graph that shows the magnitude of each frequency present in a signal, an example:&lt;/p&gt;

&lt;p&gt;Another version is the STFT, which stands for Short Time Fourier Transform that computes the FFT of short segments of an audio recording and then collates them.&lt;/p&gt;

&lt;p&gt;The Fourier Transform has been heavily used in recent years as a crucial step in many Machine Learning Pipelines.
However, with many modern programming frameworks, this is as simple as writing one line of code, and it is extremely likely that you have used technology that utilizes a fourier transform internally. The Fourier transform originates from Fourier’s&lt;/p&gt;</content><author><name>Ahmad</name></author><category term="audio" /><category term="data" /><category term="FFT" /><category term="spectrograms" /><category term="audio," /><category term="FFT," /><category term="spectrogram" /><summary type="html">Audio data can be represented in many different ways, some more useful than others for different machine learning and deep learning applications. The most famous being the Spectrogram, which illustrates the frequency components of a specific signal. Spectrogram representations, in combination with modern deep learning models tailored towards image classification and image processing, allow us to unlock a completely new perspective on solving audio related tasks. This article’s goal is to explain how we go from recorded audio to spectrogram representation in detail, with a brief explanation of the fourier transform, and assumes no prior knowledge on the subject.</summary></entry><entry><title type="html">Building an Autoencoder in Pytorch</title><link href="https://back2theprop.com/blog/Building-an-auto-encoder-in-Pytorch" rel="alternate" type="text/html" title="Building an Autoencoder in Pytorch" /><published>2021-05-14T00:00:00+03:00</published><updated>2021-05-14T00:00:00+03:00</updated><id>https://back2theprop.com/blog/Building-an-auto-encoder-in-Pytorch</id><content type="html" xml:base="https://back2theprop.com/blog/Building-an-auto-encoder-in-Pytorch">&lt;h2 id=&quot;imports-and-setup&quot;&gt;Imports and Setup&lt;/h2&gt;

&lt;p&gt;In this blog post we’ll build an autoencoder in Pytorch from scratch, and have you encoding and decoding your first images! Hop over to &lt;a href=&quot;https://colab.research.google.com/notebooks/intro.ipynb#recent=true&quot;&gt;google colab&lt;/a&gt; and open a blank notebook. To begin, we’ll want to install pytorch and torchvision, since we’ll rely on them for the components that make up our dataset. To install them into our colab notebook:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pip&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torchvision&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then we also need to import them:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torchvision&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optim&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;constructing-encoder-and-decoder&quot;&gt;Constructing Encoder and Decoder&lt;/h2&gt;

&lt;p&gt;Creating the network is also relatively easy, we create two classes, one that represents the encoder and another that represents the decoder. These classes need to a have a very specific format and should always inherit the nn.Module base class. Inheriting from the nn.Module class will automatically give our class some useful and essential properties.&lt;/p&gt;

&lt;p&gt;In python, to inherit in from another class we simply pass the class name into the parenthesis of the class that we’re creating and calling the super() function in the constructor, such as follows:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Encoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;784&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The two other things that are noteworthy here are the layer attribute that we’re creating and the forward function. Creating a class and making it inherit from nn.Module is only half the work, we also need to declare the number of layers and what kind of layers our network will have. In the case of the simple encoder, we are just going to create a single fully connected layer, that can take as input some tensor of a specific shape and outputs another tensor with a different shape. In our case we’re creating a layer that takes as input a tensor with 784 dimensions and outputs a tensor with 16 dimensions.&lt;/p&gt;

&lt;p&gt;Next up is the forward method. The forward method specifies how our neural network is connected, or ‘wired’ internally if you will. You can imagine the input to the forward method as the input to our neural network, here the input is designated by the variable ‘x’. x is then immediately passed as an input to the layer that we declared in our constructor, this means that we’re passing it through that layer and receive the output of that layer in x again, and we return it. Whatever we return from the forward method, will be the output of our neural network.&lt;/p&gt;

&lt;p&gt;We rinse and repeat the same steps for the decoder, except that the layer in the decoder has the input and output shapes reversed. This essentially means that we’re creating two separate neural networks, one that is the encoder and another that is the decoder.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Decoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;784&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;chaining-encoder-and-decoder-together&quot;&gt;Chaining Encoder and Decoder Together&lt;/h2&gt;

&lt;p&gt;Now we have two separate nets that should ultimately comprise our entire pipeline, in this manner we need to chain them together. We can do this by creating a 3rd class, that also inherits nn.Module, and which holds two member variables, that are instances of the Encoder and Decoder that we just created. This showcases the amazing modularity of pytorch, which allows us to integrate one network as a part of another network. You can also see the forward function, which again as before will pass the input x through the encoder, pass it on to the decoder and then ultimately output it.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Encoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decoder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Decoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;training-setup&quot;&gt;Training Setup&lt;/h2&gt;
&lt;p&gt;We’ve created and wired our network, now we still need to set up some stuff before we can begin training. Ideally we want to train on a GPU to accelerate this process, and since we’re on google colab, we can run our model on the provided GPU with following statements:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#  use gpu if available
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cuda&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cuda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cpu&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# create a model from `AE` autoencoder class
# load it to the specified device, either gpu or cpu
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next up we need to specify an optimizer and a criterion. The optimizer is the procedure by which we improve our neural network during training, the criterion is the metric that calculates how well or how badly we performed each training step. We’ll utilize the most standard optimizer and criterion, which are the Adam optimizer and the Mean Square Error Loss:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# create an optimizer object
# Adam optimizer with learning rate 1e-3
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;optim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Adam&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parameters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1e-3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# mean-squared error loss
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;criterion&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSELoss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The mean square error loss essentially compares the pixel values of the output to those of the input.&lt;/p&gt;

&lt;h2 id=&quot;preparing-the-dataset&quot;&gt;Preparing the Dataset&lt;/h2&gt;

&lt;p&gt;To train our network we also still need some data. We’ll train our dataset on the good old MNIST dataset that consists of greyscale images of handwritten digits that are 28x28 in dimension. Downloading it is also straightforward,&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torchvision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transforms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Compose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torchvision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transforms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ToTensor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()])&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;train_dataset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torchvision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datasets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MNIST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;~/torch_datasets&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;test_dataset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torchvision&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;datasets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MNIST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;~/torch_datasets&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;You can see that we’re actually downloading two datasets, one for training and another for testing. We also need to declare two data loaders, which will allow us to conveniently feed our dataset to our network:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;train_loader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataLoader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_dataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_workers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pin_memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;test_loader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DataLoader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_dataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_workers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;the-training-loop&quot;&gt;The training Loop&lt;/h2&gt;

&lt;p&gt;Now we’ve completed all the setup and can start training. The training loop is the most integral component of our code and we’ll go through it step by step. Firstly, we’ll create a main loop that will specify the number of epochs that we’ll train for. Every epoch our network will see the entire dataset, not all at once, but rather in small portions. The small portions are called batches. This is where the data-loaders, that we previously created, come into play. We create a loop statement that gets a batch of ‘features’ (input images), to pass to the auto encoder.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;epochs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;#training loop steps go here
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These batches of data need to be flattened such that they have the exact shape that we specified earlier when we constructed our encoder layer. In this manner we flatten the 28x28 pixel images into a linear tensor of 784 dimensions. We can do this with the view() function in pytorch. We also need to make sure that we send this batch of data to device that we’re training on (GPU, same as network):&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# reshape mini-batch data to [N, 784] matrix
# load it to the active device
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;784&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Another important function call that should generally be made before we feed the batch to our network, depending on the type of neural network you’re training and what you’re trying to achieve, is ‘zero_grad()’ on the optimizer. This function call resets the gradients to zero before backpropagation. Otherwise we would be accumulating the gradients, which is useful when training RNNs for example.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# reset the gradients back to zero
# PyTorch accumulates gradients on subsequent backward passes
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero_grad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we pass the batch to our network such that we perform a forward pass, and receive what comes out on the other end in the outputs variable. After that we need to obtain the training loss by comparing input and outputs with our specified criterion. Note that train_loss here, is not just a number but rather a tensor that has functionality:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# compute reconstructions
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outputs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# compute training reconstruction loss
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;criterion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After obtaining the training loss for a specific batch, we perform backpropagation and perform an optimizer step.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# compute accumulated gradients
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# perform parameter update based on current gradients
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We also have a variable that accumulates the loss over every batch, which we then average outside the inner loop and print to screen to verify that the network is improving and that the overall loss is decreasing:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;# add the mini-batch training loss to epoch loss
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;### Outside the batch loop ###
# compute the epoch training loss
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# display the epoch training loss
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;epoch : {}/{}, loss = {:.6f}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The training loop in it’s entirety will look like this:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;epochs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# reshape mini-batch data to [N, 784] matrix
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# load it to the active device
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;784&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# reset the gradients back to zero
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;# PyTorch accumulates gradients on subsequent backward passes
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zero_grad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# compute reconstructions
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;outputs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# compute training reconstruction loss
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;train_loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;criterion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# compute accumulated gradients
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;train_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# perform parameter update based on current gradients
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;optimizer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;# add the mini-batch training loss to epoch loss
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# compute the epoch training loss
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# display the epoch training loss
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;epoch : {}/{}, loss = {:.6f}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;epoch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;testing-the-model&quot;&gt;Testing the model&lt;/h2&gt;

&lt;p&gt;Lastly, we also want to see how well our model performs qualitatively, we can do this by looking at some of the outputs that our model outputs and compare them with the original input. We’ll need to import the matplotlib library for that and use our test_loader, which holds data that was not included in the training dataset. This will give us a good idea how well our model can generalize to new data:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;784&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
    &lt;span class=&quot;n&quot;&gt;outputs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#print(outputs.shape)
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'IMAGE'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subplot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;211&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imshow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch_features&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subplot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;212&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imshow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;outputs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;detach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;


    &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;        
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ahmad</name></author><category term="autoencoder" /><category term="encoding" /><category term="supervised" /><category term="autoencoder," /><category term="supervised" /><category term="learning" /><summary type="html">Imports and Setup</summary></entry><entry><title type="html">Origins of the Autoencoder</title><link href="https://back2theprop.com/blog/Origins-of-the-autoencoder" rel="alternate" type="text/html" title="Origins of the Autoencoder" /><published>2021-05-13T00:00:00+03:00</published><updated>2021-05-13T00:00:00+03:00</updated><id>https://back2theprop.com/blog/Origins-of-the-autoencoder</id><content type="html" xml:base="https://back2theprop.com/blog/Origins-of-the-autoencoder">&lt;p&gt;The autoencoder is a fantastic and vesatile tool to have in your Machine Learning toolkit. While the regular autoencoder is a relatively simple model, it teaches you some of the fundamental concepts of the last decade in deep learning, which gives you a foot in the door for more advanced models such as Latent variable models and generative adversarial networks, and hence making them more accessible.&lt;/p&gt;

&lt;h3 id=&quot;origins-of-the-autoencoder&quot;&gt;Origins of the Autoencoder&lt;/h3&gt;

&lt;p&gt;Interestingly, when trying to trace back the origins of the autoencoder, it seems that there is no obvious consensus about it’s origin. A cursory google search does not immediately reveal to us a clear pointer towards a distinct source. However, we are met with a Stack Exchange thread that is also discussing the same issue. One of the answers points towards an article by Schmidhuber called “Deep learning in neural networks: an overview” which recounts a history of neural networks and states that: ‘Perhaps the first work to study potential benefits of UL-based pre-training was published in 1987. It proposed unsupervised AE hierarchies (Ballard, 1987), closely related to certain post-2000 feedforward Deep Learners based on UL’. The study that he is citing here is called ‘Modular learning in neural networks’ and does indeed describe an architecture that we know today as the autoencoder.&lt;/p&gt;

&lt;p&gt;The paper by Ballard explains: ‘Activation from the input is propagated to the internal units and then back to the output, where it can be interpreted as a virtual copy. That is, it is the input as reconstructed from the internal representation. Since the input is known, this can be used to generate an error signal, just as in the feedforward case, that is then sent backwards around the network to the input weights. This architecture was first proposed by Hinton and Rumelhart’. Which leads us deeper down the rabbit hole.&lt;/p&gt;

&lt;h3 id=&quot;learning-internal-representations-by-error-propagation&quot;&gt;Learning internal representations by Error Propagation&lt;/h3&gt;

&lt;p&gt;This idea of auto-association was introduced a year earlier (1986) by Hinton and Rumelhart in their paper ‘Learning internal representations by error propagation’, as stated. Which is in concordance with other sources that also state this as being the first paper to introduce the autoencoding concept (see Autoencoders: an overview). Hinton’s paper explores the effect of hidden units when one trains a model to copy the input the output via means of error propagation. In comparison to earlier models that attempted this without any hidden units and ran into a number of issues, such as the incapability of solving specific problems like the XOR problem. Which is one of the first points that the paper addresses, Minsky and Papert proved earlier that neural networks were incapable of solving linearly inseparable problems, however when adding a hidden unit, Hinton shows that they can indeed solve the XOR problem.&lt;/p&gt;

&lt;h3 id=&quot;dimensionality-reduction&quot;&gt;Dimensionality reduction&lt;/h3&gt;
&lt;p&gt;Exploring the usefulness of autoencoding structures for dimensionality reduction began with a paper called ‘Neural Networks and Principal Component Analysis:
Learning from Examples Without Local Minima ‘ by Baldi and Hornik. They state that ‘Auto-association, which is also called auto-encoding or identity mapping (see Ackley, Hinton, &amp;amp; Sejnowski; 1985; Ellman &amp;amp; Zipser, 1988) is a simple trick intended to avoid the need for having a teacher, that is, for knowing the target values Yt, by setting Xt = Yt. In this mode, the network will tend to learn the identity map which in itself is not too exciting. However, if this is done using one narrow layer of hidden units, one expects the network to find efficient ways of compressing the information contained in the input patterns’
Fast forward a couple of years to 1993, the paper ‘Non-linear Dimensionality Reduction’ by DeMers and Cottrell discusses the usage of multi-layer encoder-decoder architectures for the sake of dimensionality reduction. The paper raises the point that an autoencoder with one hidden layer will essentially extract the principal components of the data, and proceed to show that adding an additional layer between the input, the hidden layer and the output allows the autoencoder to learn non-linear representations of the data. Both papers significantly contributed to our understanding of autoencoders today and how we actually use them today, mainly for dimensionality reduction. I wonder however why there’s a quite long gap of time between the two papers.&lt;/p&gt;

&lt;h3 id=&quot;towards-modern-applications-of-autoencoders&quot;&gt;Towards modern applications of Autoencoders&lt;/h3&gt;
&lt;p&gt;Fast forward another decade, a noteworthy article is ‘Reducing the Dimensionality of Data with Neural Networks’ again by Hinton, which may be the first study to apply auto-encoders in the context of images.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;There is something quite exciting about exploring older papers. Older papers feel a lot less standardized in comparision to current papers, and the writing style is less leaden. I recommend trying it yourself, picking some method that you are familiar with and trying to trace back it’s origins to see how it eveolved over the years with ideas from different people in different places.&lt;/p&gt;</content><author><name>Ahmad</name></author><category term="autoencoder" /><category term="history" /><category term="autoencoder," /><category term="history" /><summary type="html">The autoencoder is a fantastic and vesatile tool to have in your Machine Learning toolkit. While the regular autoencoder is a relatively simple model, it teaches you some of the fundamental concepts of the last decade in deep learning, which gives you a foot in the door for more advanced models such as Latent variable models and generative adversarial networks, and hence making them more accessible.</summary></entry><entry><title type="html">A guide to visualizing data with tSNE</title><link href="https://back2theprop.com/blog/A-guide-to-visualizing-data-with-tSNE" rel="alternate" type="text/html" title="A guide to visualizing data with tSNE" /><published>2021-05-12T00:00:00+03:00</published><updated>2021-05-12T00:00:00+03:00</updated><id>https://back2theprop.com/blog/A-guide-to-visualizing-data-with-tSNE</id><content type="html" xml:base="https://back2theprop.com/blog/A-guide-to-visualizing-data-with-tSNE">&lt;p&gt;Being able to visualize your dataset on a 2D scatter plot is probably something you want to do at the beginning of every machine learning project you tackle.&lt;/p&gt;

&lt;div style=&quot;width:100%;height:0;padding-bottom:67%;position:relative;&quot;&gt;&lt;iframe src=&quot;https://giphy.com/embed/xT0xeJpnrWC4XWblEk&quot; width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;position:absolute; pointer-events:none;&quot; frameborder=&quot;0&quot; class=&quot;giphy-embed&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;After dabbling for a while in machine learning, and building your first models you’re probably going to come to the conclusion that the method you’re using is not as important as the data that you have at your disposal. Quantity and quality being equally important here. If you’ve searched for the terms t-SNE and UMAP in a google search it is very likely that you’ve looked them up for practical purposes and to visualize the dataset that you’re working with. If you’ve come across this article then you’re in luck.&lt;/p&gt;

&lt;h3 id=&quot;on-the-dimensionality-of-data&quot;&gt;On the dimensionality of data&lt;/h3&gt;
&lt;p&gt;Data comes in many shapes and forms, from grids of pixels (digital images) to floating point arrays (audio), each of which can have many different representations depending on the situation. However, the dimensionality of this data is generally very large, which is usually inconvenient, especially when it comes to visualize our dataset. This’ll make more sense in a second. Let’s say we have a dataset that consist of a number of data-points, each of which consisting of 2 numerical features. This is easy to plot, we just assume that the first feature represents the X coordinate of the data-point, and the second feature the Y coordinate of the data-point. Now, assume we have a dataset consisting of 3 features, here we can simply add another axis, making it a 3 dimensional plot. Ok, but where do we go from here? How would you visualize 4 dimensional data? There might be some creative way to do it, however things tend to start getting messy here. The additional dimensions introduces and overhead of complexity in our plots and the algorithms to process this data. R. Bellman calls this ‘the curse of dimensionality’,&lt;/p&gt;

&lt;h3 id=&quot;dimensionality-reduction&quot;&gt;Dimensionality reduction&lt;/h3&gt;
&lt;p&gt;The good thing here, is that most of the dimensions are not really necessary, or even relevant to us. We might be able to find a subset of the features in our dataset, which is equally representative of the data points. This is where dimensionality  reduction comes into play, and it essentially does what we just described. It reduces the number of dimensions of a dataset, in such a manner that the resulting lower dimensional representation is still representative and reflects the original feature set.&lt;/p&gt;

&lt;p&gt;There are many dimensionality reduction techniques, and each for a different purpose, but in this post we will have a look at two very specific algorithms that are primarily used for visualization of high dimensional data, namely t-SNE and UMAP.&lt;/p&gt;

&lt;h3 id=&quot;briefly-about-mnist&quot;&gt;Briefly about MNIST&lt;/h3&gt;
&lt;p&gt;Let’s use the age old MNIST dataset. If, for some reason, you are not familiar with MNIST yet, it’s essentially a dataset of grayscale images of hand written digits. Each image in this dataset consists of a grid of pixels that is 28 by 28 pixels high and wide. The images are in grayscale, this means that each pixel in the image can have a real value ranging from 0.0 to 1.0, where values closer to 1.0 are almost of a purely white color.&lt;/p&gt;

&lt;h3 id=&quot;intuition-behind-t-sne&quot;&gt;Intuition behind t-SNE&lt;/h3&gt;
&lt;p&gt;t-SNE stands for t-distributed stochastic neighbour embedding, and was introduced in the paper ‘Visualizing data with t-SNE’ by Laurens van der Maaten in 2008. And more than a decade later it is still a very valid method. There have been some improvements to it over the years, obviously, and some newer methods that outperform it, but for now we’ll just focus on itself. What t-SNE tries to do intuitively, is to capture the similarities and dissimilarities of high dimensional data and represent it on a low dimensional graph, such that similarity and dissimilarity are reflected as distance on a low dimensional 2D or 3D nrighbour graph. In this manner t-SNE preserves local structure, meaning that points that are in the vicinity of each other tend to be similar, however the opposite is not always true, t-SNE can incidentally reflect some global structure but it isn’t something it was designed to do.&lt;/p&gt;

&lt;h3 id=&quot;using-t-sne&quot;&gt;Using t-SNE&lt;/h3&gt;
&lt;p&gt;t-SNE can be used out of the box in most modern data science framework toolkits. We’ll use scikit learn to use achieve this.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sklearn.manifold&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TSNE&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sklearn.datasets&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch_openml&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;numpy&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# download the dataset
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fetch_openml&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'mnist_784'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;return_X_y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as_frame&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# random selection from the dataset
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;choice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;np&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;X_sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y_sample&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# instantiate TSNE
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tsne&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TSNE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;verbose&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;feat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tsne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fit_transform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;figsize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;labels&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y_sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_cmap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'jet'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scatter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;feat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;colorbar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;legend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;plt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Ahmad</name></author><category term="t-SNE" /><category term="dimensionality-reduction" /><category term="t-SNE," /><category term="dimensionality-reduction" /><summary type="html">Being able to visualize your dataset on a 2D scatter plot is probably something you want to do at the beginning of every machine learning project you tackle.</summary></entry></feed>